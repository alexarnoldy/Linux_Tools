==== Check for open files and what users and processes have them open:
* Per user: `lsof -u <username>`
* Add `-R` to see parent processes
* All network releated connections (associates file descriptor to socket): `lsof -i`
** Can use `-i4` or `-i6` to limit output to v4 or v6
** Can limit to a port range: `lsof -i :<begining port>-<ending port>`
** Very good test to see what IP's dnsmasq is listening on: `sudo lsof -i4 | grep dnsmasq`
*** NOTE: Even if dnsmasq is listening on multiple IPs, it's configuration may limit processing requests from select interfaces
* All files open by a PID: `lsof -p <PID>`
* All proceses that have a file open: `lsof -t <absolute path of file>`
* All open files and sub-directories under a directory (seems like might be useful for unmounting): `lsof +D <absolute path of directory>`

==== Wait for something to happen before allowing a script to moving on:
* Wait for ssh to be ready after rebooting a remote host: `until nc -zv $host 22; do sleep 5; done`
* Wait for NFS server to be ready: `until sudo showmount -e; do echo "NFS server not ready" && sleep 5; done`

==== eval command:
* Can be used to create a variable that contains a command set and then execute the command set later, i.e. 
as the result of conditional test.
----
/home/user1 > a="ls | more"
/home/user1 > $a
bash: command not found: ls | more
/home/user1 > # Above command didn't work as ls tried to list files with names "|" (pipe) and "more". 
/home/user1 > # But these files do not exist.
/home/user1 > eval $a
file.txt
mailids
remote_cmd.sh
sample.txt
tmp
/home/user1 >
----

* Also used to execute the output of a command:
----
sles@admin:~/caaspv4-cluster> ssh-agent
SSH_AUTH_SOCK=/tmp/ssh-X5GHuyKyv9WL/agent.21418; export SSH_AUTH_SOCK;
SSH_AGENT_PID=21419; export SSH_AGENT_PID;
echo Agent pid 21419;
----
** The output of ssh-agent displays (but doesn't execute) the variables that need to be set and the echo command

----
sles@admin:~/caaspv4-cluster> eval "$(ssh-agent)"
Agent pid 21425
----
** eval runs those commands, including the final echo


==== sed 

.Using sed to search for one string on a line, then modify a different part of the line:
* The command below searches for lines beginning with a space, then adds a # at the beginning of the line
`sed -e '/^\ / s/^#*/#/' <file>`
* The command bellow searches for lines containing the word driver, the substitutes the word overlay with the word vfs in any of those lines
`sed -i '/driver/ s/overlay/vfs/' <file>`
** This avoids replacing other places where the word overlay occurs, i.e. overlayfs 
* Comment lines two through four, no matter what those lines contain (in-place edit): `sed -i '2,4 s/^/#/' <file>`
** The equivilent in vim would be `:` `2,4 s/^/#/`
* Search for the line that begins with 127 and then remove localhost (outputs updated file contents to stdout, does not update file): `sed -e '/^127/ s/localhost//' /etc/hosts`
* Search for the line that begins with 127, remove localhost, then insert a new line under it with the string that follows the "/a" (use "/i" for insert above the line returned by the search string) (outputs updated file contents to stdout, does not update file): 
** `sed -e '/^127/ s/localhost//' -e '/^127/a 172.16.200.132    ses-osd-c.stable.suse.lab    ses-osd-c    localhost' /etc/hosts`
*** Note that the single quotes will prevent variable expansion
* if you want to insert multiple lines, you can use ‘\n’ as shown below.

`sed '/^anothervalue=.*/i before=me\nbefore2=me2' test.txt`

==== awk

.Instead of `grep | awk`, can use awk to do both:
* Show the first field of every line that contains the expression "important=no": `snapper list | awk '/important=no/{print$1}'`
* Show the entire line of every line that contains the expression "important=no": `snapper list | awk '/important=no/{print$0}'`
** Since print is the default action, the above is same as: `snapper list | awk '/important=no/'`

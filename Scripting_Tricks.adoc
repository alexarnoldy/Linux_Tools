==== Using arrays in BASH
* Create an array: `TEST_ARRAY=(one two three)`
** Create an array with a command: 
----
CMD="ls ./infrastructure"; IFS=$'\n' read -r -d '' -a TEST_ARRAY < <( ${CMD} && printf '\0' )
----
* Show the number of entries in an array: `echo "${#TEST_ARRAY[*]}"`
* Arrays index from 0. Print the first value in the array: `echo "${TEST_ARRAY[0]}"`
* Print all entries in the array: `echo "${TEST_ARRAY[*]}"`
* Iterate over an array:
----
for EACH in ${!TEST_ARRAY[*]} 
do 
	printf ${EACH}") " # Print the index number followed by right parenthesis and a space
	echo "${TEST_ARRAY[EACH]}" # Print the contents of this array index
done
----

==== Menuing system that allows selecting and deselecting values from an array:

----
IFS=$'\n' read -r -d '' -a options < <( ls ./infrastructure && printf '\0' )


clear
menu() {
    echo "Select the target KVM host(s):"
    for i in ${!options[@]}; do
        printf "%3d%s) %s\n" $((i+1)) "${choices[i]:- }" "${options[i]}"
    done
    if [[ "$msg" ]]; then echo "$msg"; fi
}

prompt="Select a host then ENTER (repeat to deselect it, press ENTER on an empty line when done): "
while menu && read -rp "$prompt" num && [[ "$num" ]]; do
    [[ "$num" != *[![:digit:]]* ]] &&
    (( num > 0 && num <= ${#options[@]} )) ||
    { msg="Invalid option: $num"; continue; }
    ((num--)); msg="${options[num]} was ${choices[num]:+un}checked"
    [[ "${choices[num]}" ]] && choices[num]="" || choices[num]="+"
    clear
done

clear

for EACH in ${!options[@]}; do
#    [[ "${choices[EACH]}" ]] && { printf " %s" "${options[EACH]}"; msg=""; }
[[ "${choices[EACH]}" ]] && KVM_HOST="${options[EACH]}" && KVM_USER=$(awk '/KVM_USER/ {print$2}' infrastructure/"${options[EACH]}") && func_exec_tf_action
done
----

==== Simpler menuing system that allows selecting any combination of elements in an array
* The case statement also parses combinations of inputs such as 1, 1 2 3, and 1..3:
----
IFS=$'\n' read -r -d '' -a ALL_KVM_HOSTS < <( ls ./infrastructure && printf '\0' )

clear

echo "Select one or more of the following KVM hosts:"

for EACH in ${!ALL_KVM_HOSTS[@]}; do printf ${EACH}") "; echo "${ALL_KVM_HOSTS[EACH]}"; done

echo "Enter the host numbers for deployment in formats of:"
echo "a single number (i.e. 1),"
echo "a space separated list (i.e. 1 3),"
read -p "or a range (i.e. 2..4): " SELECTED_KVM_HOSTS

case ${SELECTED_KVM_HOSTS} in
       *..*)
               for EACH in $(eval echo "{$SELECTED_KVM_HOSTS}")
               do
                       echo "${ALL_KVM_HOSTS[EACH]}"
               done
               ;;

       *)
               for EACH in $(echo ${SELECTED_KVM_HOSTS})
               do
                       echo "${ALL_KVM_HOSTS[EACH]}"
               done
               ;;
esac
----

==== Use nmap and ipcalc to find the resolvable hosts on an attached network:
* Just the resolved hostnames:
----
nmap -sL $(ipcalc $(ip a | grep eth0$ | awk '{print$2}') | awk '/Network:/{print$2}') | grep \)$ | awk '{print$5}' 
----
* The IP address with hostnames:
----
nmap -sL $(ipcalc $(ip a | grep eth0$ | awk '{print$2}') | awk '/Network:/{print$2}') | grep \)$ | awk '{print$6$5}' | sed -e 's/(//' -e 's/)/\ /'
----
* Same as above but without ipcalc:
----
nmap -sL $(ip a | grep eth0$ | awk '{print$2}') | grep \)$ | awk '{print$6$5}' | sed -e 's/(//' -e 's/)/\ /'
----


==== Check for open files and what users and processes have them open:
* Per user: `sudo lsof -u <username>`
* Add `-R` to see parent processes
* All network releated connections (associates file descriptor to socket): `sudo lsof -i`
** Can use `-i4` or `-i6` to limit output to v4 or v6
** Can limit to a port range: `sudo lsof -i :<begining port>-<ending port>`
** Very good test to see what IP's dnsmasq is listening on: `sudo lsof -i4 | grep dnsmasq`
*** NOTE: Even if dnsmasq is listening on multiple IPs, it's configuration may limit processing requests from select interfaces
* All files open by a PID: `sudo lsof -p <PID>`
* All proceses that have a file open: `sudo lsof -t <absolute path of file>`
* All open files and sub-directories under a directory (seems like might be useful for unmounting): `sudo lsof +D <absolute path of directory>`

==== Wait for something to happen before allowing a script to moving on:
* Wait for ssh to be ready after rebooting a remote host: `until nc -zv $host 22; do sleep 5; done`
* Wait for NFS server to be ready: `until sudo showmount -e; do echo "NFS server not ready" && sleep 5; done`

==== eval command:
* Can be used to create a variable that contains a command set and then execute the command set later, i.e. 
as the result of conditional test.
----
/home/user1 > a="ls | more"
/home/user1 > $a
bash: command not found: ls | more
/home/user1 > # Above command didn't work as ls tried to list files with names "|" (pipe) and "more". 
/home/user1 > # But these files do not exist.
/home/user1 > eval $a
file.txt
mailids
remote_cmd.sh
sample.txt
tmp
/home/user1 >
----

* Also used to execute the output of a command:
----
sles@admin:~/caaspv4-cluster> ssh-agent
SSH_AUTH_SOCK=/tmp/ssh-X5GHuyKyv9WL/agent.21418; export SSH_AUTH_SOCK;
SSH_AGENT_PID=21419; export SSH_AGENT_PID;
echo Agent pid 21419;
----
** The output of ssh-agent displays (but doesn't execute) the variables that need to be set and the echo command

----
sles@admin:~/caaspv4-cluster> eval "$(ssh-agent)"
Agent pid 21425
----
** eval runs those commands, including the final echo


==== sed 

.Using sed to search for one string on a line, then modify a different part of the line:
* The command below searches for lines beginning with a space, then adds a # at the beginning of the line
`sed -e '/^\ / s/^#*/#/' <file>`
* The command bellow searches for lines containing the word driver, the substitutes the word overlay with the word vfs in any of those lines
`sed -i '/driver/ s/overlay/vfs/' <file>`
** This avoids replacing other places where the word overlay occurs, i.e. overlayfs 
* Comment lines two through four, no matter what those lines contain (in-place edit): `sed -i '2,4 s/^/#/' <file>`
** The equivilent in vim would be `:` `2,4 s/^/#/`
* Search for the line that begins with 127 and then remove localhost (outputs updated file contents to stdout, does not update file): `sed -e '/^127/ s/localhost//' /etc/hosts`
* Search for the line that begins with 127, remove localhost, then insert a new line under it with the string that follows the "/a" (use "/i" for insert above the line returned by the search string) (outputs updated file contents to stdout, does not update file): 
** `sed -e '/^127/ s/localhost//' -e '/^127/a 172.16.200.132    ses-osd-c.stable.suse.lab    ses-osd-c    localhost' /etc/hosts`
*** Note that the single quotes will prevent variable expansion
* if you want to insert multiple lines, you can use ‘\n’ as shown below.

`sed '/^anothervalue=.*/i before=me\nbefore2=me2' test.txt`

==== awk

.Instead of `grep | awk`, can use awk to do both:
* Show the first field of every line that contains the expression "important=no": `snapper list | awk '/important=no/{print$1}'`
* Show the entire line of every line that contains the expression "important=no": `snapper list | awk '/important=no/{print$0}'`
** Since print is the default action, the above is same as: `snapper list | awk '/important=no/'`
* Print all but very first column: `awk '{$1=""; print $0}' somefile`
* Print all but two first columns: `awk '{$1=$2=""; print $0}' somefile`
* Print the number of columns in the line that starts with PUB_KEY: `awk '/^PUB_KEY/ {print NF}' somefile`
* Print the last column: `awk '/^PUB_KEY/ {print$NF}' somefile` 

==== egrep

.Use egrep as a test:
* Takes the exit status of egrep and runs the second half if exit status is not zero
** Note that the second half of the expression consists of two commands that get run as a whole if exit status is not zero:
----
egrep '^flags.*(vmx|svm)' /proc/cpuinfo || (echo CPU virtualization is not enabled; exit 9)
----
